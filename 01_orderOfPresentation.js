// 말썽꾸러기 김코딩은 오늘도 장난을 치다가 조별 발표 순서가 담긴 통을 쏟고 말았습니다.
// 선생님께서는 미리 모든 발표 순서의 경우의 수를 저장해 놓았지만 김코딩의 버릇을 고치기 위해 문제를 내겠다고 말씀하셨습니다.
// 김코딩은 모든 조별 발표 순서에 대한 경우의 수를 차례대로 구한 뒤 발표 순서를 말하면 이 발표 순서가 몇 번째 경우의 수인지를 대답해야 합니다.
// 총 조의 수 N과 선생님이 말씀하시는 발표 순서 k가 주어질 때, 김코딩이 정답을 말 할 수 있게 올바른 리턴 값을 구하세요.
// 모든 경우의 수가 담긴 배열은 번호가 작을수록 앞에 위치한다고 가정합니다.
// ex) N = 3일경우, [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
// N은 Number 타입의 1 <= N <= 12인 조의 개수
// K는 Number타입의 Array (0 <= index)
// K내에 중복되는 요소는 없다고 가정합니다.

// N,K 가 주어질때 N의 모든 경우의 수를 담은 배열에서 K의 인덱스를 리턴해야한다.

function orderOfPresentation (N, K) {
  // TODO: 여기에 코드를 작성합니다.
  let num = 0;
  let result = 0;
  
  // 1단계 : 재귀함수를 만들어준다 
  const factorial = (a) => {
    if(a === 1 || a<=0 ){
      return 1 
    }
    return a*factorial(a-1)
  }
  
  // 2단계 : 재귀함수를 사용해 결과 값을 구한다
  for(let i=0;i<N;i++){
    num = 0; 
    for(let j=i+1;j<N;j++){
        if(K[i]>K[j]){
          num++
        }
    }
    result = result + (num * factorial(N-1-i))
  }
  return result 
}